/**
 * Generated by orval v7.3.0 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import type {
  BodyAuthJwtLoginAuthLoginPost,
  BodyCreateStudentApiStudentsPost,
  BodyCreateStudentsByCsvApiStudentsCsvPost,
  BodyRecognizeApiFacialRecognitionRecognizePost,
  BodyResetForgotPasswordAuthForgotPasswordPost,
  BodyResetResetPasswordAuthResetPasswordPost,
  BodyUpdateStudentByRaApiStudentsStudentRaPatch,
  BodyVerifyRequestTokenAuthRequestVerifyTokenPost,
  BodyVerifyVerifyAuthVerifyPost,
  DeepFaceRepresentRequest,
  DeepFaceVerifyRequest,
  ErrorModel,
  HTTPValidationError,
  UserCreate,
  UserRead,
  UserUpdate
} from './model'
import { customInstance } from './api/mutator/custom-instance';
import type { ErrorType, BodyType } from './api/mutator/custom-instance';


// eslint-disable-next-line @typescript-eslint/no-explicit-any
type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];


/**
 * @summary Auth:Jwt.Login
 */
export const authJwtLoginAuthLoginPost = (
    bodyAuthJwtLoginAuthLoginPost: BodyType<BodyAuthJwtLoginAuthLoginPost>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      const formUrlEncoded = new URLSearchParams();
if(bodyAuthJwtLoginAuthLoginPost.grant_type !== undefined && bodyAuthJwtLoginAuthLoginPost.grant_type !== null) {
 formUrlEncoded.append('grant_type', bodyAuthJwtLoginAuthLoginPost.grant_type)
 }
formUrlEncoded.append('username', bodyAuthJwtLoginAuthLoginPost.username)
formUrlEncoded.append('password', bodyAuthJwtLoginAuthLoginPost.password)
if(bodyAuthJwtLoginAuthLoginPost.scope !== undefined) {
 formUrlEncoded.append('scope', bodyAuthJwtLoginAuthLoginPost.scope)
 }
if(bodyAuthJwtLoginAuthLoginPost.client_id !== undefined && bodyAuthJwtLoginAuthLoginPost.client_id !== null) {
 formUrlEncoded.append('client_id', bodyAuthJwtLoginAuthLoginPost.client_id)
 }
if(bodyAuthJwtLoginAuthLoginPost.client_secret !== undefined && bodyAuthJwtLoginAuthLoginPost.client_secret !== null) {
 formUrlEncoded.append('client_secret', bodyAuthJwtLoginAuthLoginPost.client_secret)
 }

      return customInstance<unknown | void>(
      {url: `/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/x-www-form-urlencoded', },
       data: formUrlEncoded, signal
    },
      options);
    }
  


export const getAuthJwtLoginAuthLoginPostMutationOptions = <TError = ErrorType<ErrorModel | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authJwtLoginAuthLoginPost>>, TError,{data: BodyType<BodyAuthJwtLoginAuthLoginPost>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authJwtLoginAuthLoginPost>>, TError,{data: BodyType<BodyAuthJwtLoginAuthLoginPost>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authJwtLoginAuthLoginPost>>, {data: BodyType<BodyAuthJwtLoginAuthLoginPost>}> = (props) => {
          const {data} = props ?? {};

          return  authJwtLoginAuthLoginPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthJwtLoginAuthLoginPostMutationResult = NonNullable<Awaited<ReturnType<typeof authJwtLoginAuthLoginPost>>>
    export type AuthJwtLoginAuthLoginPostMutationBody = BodyType<BodyAuthJwtLoginAuthLoginPost>
    export type AuthJwtLoginAuthLoginPostMutationError = ErrorType<ErrorModel | HTTPValidationError>

    /**
 * @summary Auth:Jwt.Login
 */
export const useAuthJwtLoginAuthLoginPost = <TError = ErrorType<ErrorModel | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authJwtLoginAuthLoginPost>>, TError,{data: BodyType<BodyAuthJwtLoginAuthLoginPost>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof authJwtLoginAuthLoginPost>>,
        TError,
        {data: BodyType<BodyAuthJwtLoginAuthLoginPost>},
        TContext
      > => {

      const mutationOptions = getAuthJwtLoginAuthLoginPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Auth:Jwt.Logout
 */
export const authJwtLogoutAuthLogoutPost = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown | void>(
      {url: `/auth/logout`, method: 'POST', signal
    },
      options);
    }
  


export const getAuthJwtLogoutAuthLogoutPostMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authJwtLogoutAuthLogoutPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authJwtLogoutAuthLogoutPost>>, TError,void, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authJwtLogoutAuthLogoutPost>>, void> = () => {
          

          return  authJwtLogoutAuthLogoutPost(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthJwtLogoutAuthLogoutPostMutationResult = NonNullable<Awaited<ReturnType<typeof authJwtLogoutAuthLogoutPost>>>
    
    export type AuthJwtLogoutAuthLogoutPostMutationError = ErrorType<void>

    /**
 * @summary Auth:Jwt.Logout
 */
export const useAuthJwtLogoutAuthLogoutPost = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authJwtLogoutAuthLogoutPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof authJwtLogoutAuthLogoutPost>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAuthJwtLogoutAuthLogoutPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Register:Register
 */
export const registerRegisterAuthRegisterPost = (
    userCreate: BodyType<UserCreate>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserRead>(
      {url: `/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreate, signal
    },
      options);
    }
  


export const getRegisterRegisterAuthRegisterPostMutationOptions = <TError = ErrorType<ErrorModel | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>, TError,{data: BodyType<UserCreate>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>, TError,{data: BodyType<UserCreate>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>, {data: BodyType<UserCreate>}> = (props) => {
          const {data} = props ?? {};

          return  registerRegisterAuthRegisterPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterRegisterAuthRegisterPostMutationResult = NonNullable<Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>>
    export type RegisterRegisterAuthRegisterPostMutationBody = BodyType<UserCreate>
    export type RegisterRegisterAuthRegisterPostMutationError = ErrorType<ErrorModel | HTTPValidationError>

    /**
 * @summary Register:Register
 */
export const useRegisterRegisterAuthRegisterPost = <TError = ErrorType<ErrorModel | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>, TError,{data: BodyType<UserCreate>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>,
        TError,
        {data: BodyType<UserCreate>},
        TContext
      > => {

      const mutationOptions = getRegisterRegisterAuthRegisterPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Reset:Forgot Password
 */
export const resetForgotPasswordAuthForgotPasswordPost = (
    bodyResetForgotPasswordAuthForgotPasswordPost: BodyType<BodyResetForgotPasswordAuthForgotPasswordPost>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/auth/forgot-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bodyResetForgotPasswordAuthForgotPasswordPost, signal
    },
      options);
    }
  


export const getResetForgotPasswordAuthForgotPasswordPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>, TError,{data: BodyType<BodyResetForgotPasswordAuthForgotPasswordPost>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>, TError,{data: BodyType<BodyResetForgotPasswordAuthForgotPasswordPost>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>, {data: BodyType<BodyResetForgotPasswordAuthForgotPasswordPost>}> = (props) => {
          const {data} = props ?? {};

          return  resetForgotPasswordAuthForgotPasswordPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResetForgotPasswordAuthForgotPasswordPostMutationResult = NonNullable<Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>>
    export type ResetForgotPasswordAuthForgotPasswordPostMutationBody = BodyType<BodyResetForgotPasswordAuthForgotPasswordPost>
    export type ResetForgotPasswordAuthForgotPasswordPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Reset:Forgot Password
 */
export const useResetForgotPasswordAuthForgotPasswordPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>, TError,{data: BodyType<BodyResetForgotPasswordAuthForgotPasswordPost>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>,
        TError,
        {data: BodyType<BodyResetForgotPasswordAuthForgotPasswordPost>},
        TContext
      > => {

      const mutationOptions = getResetForgotPasswordAuthForgotPasswordPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Reset:Reset Password
 */
export const resetResetPasswordAuthResetPasswordPost = (
    bodyResetResetPasswordAuthResetPasswordPost: BodyType<BodyResetResetPasswordAuthResetPasswordPost>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/auth/reset-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bodyResetResetPasswordAuthResetPasswordPost, signal
    },
      options);
    }
  


export const getResetResetPasswordAuthResetPasswordPostMutationOptions = <TError = ErrorType<ErrorModel | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>, TError,{data: BodyType<BodyResetResetPasswordAuthResetPasswordPost>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>, TError,{data: BodyType<BodyResetResetPasswordAuthResetPasswordPost>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>, {data: BodyType<BodyResetResetPasswordAuthResetPasswordPost>}> = (props) => {
          const {data} = props ?? {};

          return  resetResetPasswordAuthResetPasswordPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResetResetPasswordAuthResetPasswordPostMutationResult = NonNullable<Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>>
    export type ResetResetPasswordAuthResetPasswordPostMutationBody = BodyType<BodyResetResetPasswordAuthResetPasswordPost>
    export type ResetResetPasswordAuthResetPasswordPostMutationError = ErrorType<ErrorModel | HTTPValidationError>

    /**
 * @summary Reset:Reset Password
 */
export const useResetResetPasswordAuthResetPasswordPost = <TError = ErrorType<ErrorModel | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>, TError,{data: BodyType<BodyResetResetPasswordAuthResetPasswordPost>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>,
        TError,
        {data: BodyType<BodyResetResetPasswordAuthResetPasswordPost>},
        TContext
      > => {

      const mutationOptions = getResetResetPasswordAuthResetPasswordPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Verify:Request-Token
 */
export const verifyRequestTokenAuthRequestVerifyTokenPost = (
    bodyVerifyRequestTokenAuthRequestVerifyTokenPost: BodyType<BodyVerifyRequestTokenAuthRequestVerifyTokenPost>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/auth/request-verify-token`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bodyVerifyRequestTokenAuthRequestVerifyTokenPost, signal
    },
      options);
    }
  


export const getVerifyRequestTokenAuthRequestVerifyTokenPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>, TError,{data: BodyType<BodyVerifyRequestTokenAuthRequestVerifyTokenPost>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>, TError,{data: BodyType<BodyVerifyRequestTokenAuthRequestVerifyTokenPost>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>, {data: BodyType<BodyVerifyRequestTokenAuthRequestVerifyTokenPost>}> = (props) => {
          const {data} = props ?? {};

          return  verifyRequestTokenAuthRequestVerifyTokenPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyRequestTokenAuthRequestVerifyTokenPostMutationResult = NonNullable<Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>>
    export type VerifyRequestTokenAuthRequestVerifyTokenPostMutationBody = BodyType<BodyVerifyRequestTokenAuthRequestVerifyTokenPost>
    export type VerifyRequestTokenAuthRequestVerifyTokenPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Verify:Request-Token
 */
export const useVerifyRequestTokenAuthRequestVerifyTokenPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>, TError,{data: BodyType<BodyVerifyRequestTokenAuthRequestVerifyTokenPost>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>,
        TError,
        {data: BodyType<BodyVerifyRequestTokenAuthRequestVerifyTokenPost>},
        TContext
      > => {

      const mutationOptions = getVerifyRequestTokenAuthRequestVerifyTokenPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Verify:Verify
 */
export const verifyVerifyAuthVerifyPost = (
    bodyVerifyVerifyAuthVerifyPost: BodyType<BodyVerifyVerifyAuthVerifyPost>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserRead>(
      {url: `/auth/verify`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bodyVerifyVerifyAuthVerifyPost, signal
    },
      options);
    }
  


export const getVerifyVerifyAuthVerifyPostMutationOptions = <TError = ErrorType<ErrorModel | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>, TError,{data: BodyType<BodyVerifyVerifyAuthVerifyPost>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>, TError,{data: BodyType<BodyVerifyVerifyAuthVerifyPost>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>, {data: BodyType<BodyVerifyVerifyAuthVerifyPost>}> = (props) => {
          const {data} = props ?? {};

          return  verifyVerifyAuthVerifyPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyVerifyAuthVerifyPostMutationResult = NonNullable<Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>>
    export type VerifyVerifyAuthVerifyPostMutationBody = BodyType<BodyVerifyVerifyAuthVerifyPost>
    export type VerifyVerifyAuthVerifyPostMutationError = ErrorType<ErrorModel | HTTPValidationError>

    /**
 * @summary Verify:Verify
 */
export const useVerifyVerifyAuthVerifyPost = <TError = ErrorType<ErrorModel | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>, TError,{data: BodyType<BodyVerifyVerifyAuthVerifyPost>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>,
        TError,
        {data: BodyType<BodyVerifyVerifyAuthVerifyPost>},
        TContext
      > => {

      const mutationOptions = getVerifyVerifyAuthVerifyPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Users:Current User
 */
export const usersCurrentUserUsersMeGet = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserRead>(
      {url: `/users/me`, method: 'GET', signal
    },
      options);
    }
  

export const getUsersCurrentUserUsersMeGetQueryKey = () => {
    return [`/users/me`] as const;
    }

    
export const getUsersCurrentUserUsersMeGetQueryOptions = <TData = Awaited<ReturnType<typeof usersCurrentUserUsersMeGet>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersCurrentUserUsersMeGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersCurrentUserUsersMeGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersCurrentUserUsersMeGet>>> = ({ signal }) => usersCurrentUserUsersMeGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersCurrentUserUsersMeGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type UsersCurrentUserUsersMeGetQueryResult = NonNullable<Awaited<ReturnType<typeof usersCurrentUserUsersMeGet>>>
export type UsersCurrentUserUsersMeGetQueryError = ErrorType<void>


export function useUsersCurrentUserUsersMeGet<TData = Awaited<ReturnType<typeof usersCurrentUserUsersMeGet>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersCurrentUserUsersMeGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersCurrentUserUsersMeGet>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUsersCurrentUserUsersMeGet<TData = Awaited<ReturnType<typeof usersCurrentUserUsersMeGet>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersCurrentUserUsersMeGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersCurrentUserUsersMeGet>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUsersCurrentUserUsersMeGet<TData = Awaited<ReturnType<typeof usersCurrentUserUsersMeGet>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersCurrentUserUsersMeGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Users:Current User
 */

export function useUsersCurrentUserUsersMeGet<TData = Awaited<ReturnType<typeof usersCurrentUserUsersMeGet>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersCurrentUserUsersMeGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getUsersCurrentUserUsersMeGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Users:Patch Current User
 */
export const usersPatchCurrentUserUsersMePatch = (
    userUpdate: BodyType<UserUpdate>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UserRead>(
      {url: `/users/me`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: userUpdate
    },
      options);
    }
  


export const getUsersPatchCurrentUserUsersMePatchMutationOptions = <TError = ErrorType<ErrorModel | void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersPatchCurrentUserUsersMePatch>>, TError,{data: BodyType<UserUpdate>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof usersPatchCurrentUserUsersMePatch>>, TError,{data: BodyType<UserUpdate>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersPatchCurrentUserUsersMePatch>>, {data: BodyType<UserUpdate>}> = (props) => {
          const {data} = props ?? {};

          return  usersPatchCurrentUserUsersMePatch(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersPatchCurrentUserUsersMePatchMutationResult = NonNullable<Awaited<ReturnType<typeof usersPatchCurrentUserUsersMePatch>>>
    export type UsersPatchCurrentUserUsersMePatchMutationBody = BodyType<UserUpdate>
    export type UsersPatchCurrentUserUsersMePatchMutationError = ErrorType<ErrorModel | void | HTTPValidationError>

    /**
 * @summary Users:Patch Current User
 */
export const useUsersPatchCurrentUserUsersMePatch = <TError = ErrorType<ErrorModel | void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersPatchCurrentUserUsersMePatch>>, TError,{data: BodyType<UserUpdate>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof usersPatchCurrentUserUsersMePatch>>,
        TError,
        {data: BodyType<UserUpdate>},
        TContext
      > => {

      const mutationOptions = getUsersPatchCurrentUserUsersMePatchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Users:User
 */
export const usersUserUsersIdGet = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserRead>(
      {url: `/users/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getUsersUserUsersIdGetQueryKey = (id: string,) => {
    return [`/users/${id}`] as const;
    }

    
export const getUsersUserUsersIdGetQueryOptions = <TData = Awaited<ReturnType<typeof usersUserUsersIdGet>>, TError = ErrorType<void | HTTPValidationError>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersUserUsersIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersUserUsersIdGetQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersUserUsersIdGet>>> = ({ signal }) => usersUserUsersIdGet(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersUserUsersIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type UsersUserUsersIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof usersUserUsersIdGet>>>
export type UsersUserUsersIdGetQueryError = ErrorType<void | HTTPValidationError>


export function useUsersUserUsersIdGet<TData = Awaited<ReturnType<typeof usersUserUsersIdGet>>, TError = ErrorType<void | HTTPValidationError>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersUserUsersIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersUserUsersIdGet>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUsersUserUsersIdGet<TData = Awaited<ReturnType<typeof usersUserUsersIdGet>>, TError = ErrorType<void | HTTPValidationError>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersUserUsersIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersUserUsersIdGet>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useUsersUserUsersIdGet<TData = Awaited<ReturnType<typeof usersUserUsersIdGet>>, TError = ErrorType<void | HTTPValidationError>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersUserUsersIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Users:User
 */

export function useUsersUserUsersIdGet<TData = Awaited<ReturnType<typeof usersUserUsersIdGet>>, TError = ErrorType<void | HTTPValidationError>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersUserUsersIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getUsersUserUsersIdGetQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Users:Patch User
 */
export const usersPatchUserUsersIdPatch = (
    id: string,
    userUpdate: BodyType<UserUpdate>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UserRead>(
      {url: `/users/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: userUpdate
    },
      options);
    }
  


export const getUsersPatchUserUsersIdPatchMutationOptions = <TError = ErrorType<ErrorModel | void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersPatchUserUsersIdPatch>>, TError,{id: string;data: BodyType<UserUpdate>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof usersPatchUserUsersIdPatch>>, TError,{id: string;data: BodyType<UserUpdate>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersPatchUserUsersIdPatch>>, {id: string;data: BodyType<UserUpdate>}> = (props) => {
          const {id,data} = props ?? {};

          return  usersPatchUserUsersIdPatch(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersPatchUserUsersIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof usersPatchUserUsersIdPatch>>>
    export type UsersPatchUserUsersIdPatchMutationBody = BodyType<UserUpdate>
    export type UsersPatchUserUsersIdPatchMutationError = ErrorType<ErrorModel | void | HTTPValidationError>

    /**
 * @summary Users:Patch User
 */
export const useUsersPatchUserUsersIdPatch = <TError = ErrorType<ErrorModel | void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersPatchUserUsersIdPatch>>, TError,{id: string;data: BodyType<UserUpdate>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof usersPatchUserUsersIdPatch>>,
        TError,
        {id: string;data: BodyType<UserUpdate>},
        TContext
      > => {

      const mutationOptions = getUsersPatchUserUsersIdPatchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Users:Delete User
 */
export const usersDeleteUserUsersIdDelete = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/users/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getUsersDeleteUserUsersIdDeleteMutationOptions = <TError = ErrorType<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersDeleteUserUsersIdDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof usersDeleteUserUsersIdDelete>>, TError,{id: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersDeleteUserUsersIdDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  usersDeleteUserUsersIdDelete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UsersDeleteUserUsersIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof usersDeleteUserUsersIdDelete>>>
    
    export type UsersDeleteUserUsersIdDeleteMutationError = ErrorType<void | HTTPValidationError>

    /**
 * @summary Users:Delete User
 */
export const useUsersDeleteUserUsersIdDelete = <TError = ErrorType<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersDeleteUserUsersIdDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof usersDeleteUserUsersIdDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getUsersDeleteUserUsersIdDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get All Students
 */
export const getAllStudentsApiStudentsGet = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/students`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllStudentsApiStudentsGetQueryKey = () => {
    return [`/api/students`] as const;
    }

    
export const getGetAllStudentsApiStudentsGetQueryOptions = <TData = Awaited<ReturnType<typeof getAllStudentsApiStudentsGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllStudentsApiStudentsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllStudentsApiStudentsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllStudentsApiStudentsGet>>> = ({ signal }) => getAllStudentsApiStudentsGet(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllStudentsApiStudentsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAllStudentsApiStudentsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAllStudentsApiStudentsGet>>>
export type GetAllStudentsApiStudentsGetQueryError = ErrorType<unknown>


export function useGetAllStudentsApiStudentsGet<TData = Awaited<ReturnType<typeof getAllStudentsApiStudentsGet>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllStudentsApiStudentsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllStudentsApiStudentsGet>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAllStudentsApiStudentsGet<TData = Awaited<ReturnType<typeof getAllStudentsApiStudentsGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllStudentsApiStudentsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllStudentsApiStudentsGet>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAllStudentsApiStudentsGet<TData = Awaited<ReturnType<typeof getAllStudentsApiStudentsGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllStudentsApiStudentsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get All Students
 */

export function useGetAllStudentsApiStudentsGet<TData = Awaited<ReturnType<typeof getAllStudentsApiStudentsGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllStudentsApiStudentsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAllStudentsApiStudentsGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create Student
 */
export const createStudentApiStudentsPost = (
    bodyCreateStudentApiStudentsPost: BodyType<BodyCreateStudentApiStudentsPost>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append('name', bodyCreateStudentApiStudentsPost.name)
formUrlEncoded.append('ra', bodyCreateStudentApiStudentsPost.ra.toString())
formUrlEncoded.append('image_base64', bodyCreateStudentApiStudentsPost.image_base64)

      return customInstance<unknown>(
      {url: `/api/students`, method: 'POST',
      headers: {'Content-Type': 'application/x-www-form-urlencoded', },
       data: formUrlEncoded, signal
    },
      options);
    }
  


export const getCreateStudentApiStudentsPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createStudentApiStudentsPost>>, TError,{data: BodyType<BodyCreateStudentApiStudentsPost>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createStudentApiStudentsPost>>, TError,{data: BodyType<BodyCreateStudentApiStudentsPost>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createStudentApiStudentsPost>>, {data: BodyType<BodyCreateStudentApiStudentsPost>}> = (props) => {
          const {data} = props ?? {};

          return  createStudentApiStudentsPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateStudentApiStudentsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createStudentApiStudentsPost>>>
    export type CreateStudentApiStudentsPostMutationBody = BodyType<BodyCreateStudentApiStudentsPost>
    export type CreateStudentApiStudentsPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Create Student
 */
export const useCreateStudentApiStudentsPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createStudentApiStudentsPost>>, TError,{data: BodyType<BodyCreateStudentApiStudentsPost>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createStudentApiStudentsPost>>,
        TError,
        {data: BodyType<BodyCreateStudentApiStudentsPost>},
        TContext
      > => {

      const mutationOptions = getCreateStudentApiStudentsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get Student By Ra
 */
export const getStudentByRaApiStudentsStudentRaGet = (
    studentRa: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/students/${studentRa}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetStudentByRaApiStudentsStudentRaGetQueryKey = (studentRa: number,) => {
    return [`/api/students/${studentRa}`] as const;
    }

    
export const getGetStudentByRaApiStudentsStudentRaGetQueryOptions = <TData = Awaited<ReturnType<typeof getStudentByRaApiStudentsStudentRaGet>>, TError = ErrorType<HTTPValidationError>>(studentRa: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentByRaApiStudentsStudentRaGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStudentByRaApiStudentsStudentRaGetQueryKey(studentRa);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStudentByRaApiStudentsStudentRaGet>>> = ({ signal }) => getStudentByRaApiStudentsStudentRaGet(studentRa, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(studentRa), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStudentByRaApiStudentsStudentRaGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetStudentByRaApiStudentsStudentRaGetQueryResult = NonNullable<Awaited<ReturnType<typeof getStudentByRaApiStudentsStudentRaGet>>>
export type GetStudentByRaApiStudentsStudentRaGetQueryError = ErrorType<HTTPValidationError>


export function useGetStudentByRaApiStudentsStudentRaGet<TData = Awaited<ReturnType<typeof getStudentByRaApiStudentsStudentRaGet>>, TError = ErrorType<HTTPValidationError>>(
 studentRa: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentByRaApiStudentsStudentRaGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStudentByRaApiStudentsStudentRaGet>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetStudentByRaApiStudentsStudentRaGet<TData = Awaited<ReturnType<typeof getStudentByRaApiStudentsStudentRaGet>>, TError = ErrorType<HTTPValidationError>>(
 studentRa: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentByRaApiStudentsStudentRaGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStudentByRaApiStudentsStudentRaGet>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetStudentByRaApiStudentsStudentRaGet<TData = Awaited<ReturnType<typeof getStudentByRaApiStudentsStudentRaGet>>, TError = ErrorType<HTTPValidationError>>(
 studentRa: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentByRaApiStudentsStudentRaGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get Student By Ra
 */

export function useGetStudentByRaApiStudentsStudentRaGet<TData = Awaited<ReturnType<typeof getStudentByRaApiStudentsStudentRaGet>>, TError = ErrorType<HTTPValidationError>>(
 studentRa: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStudentByRaApiStudentsStudentRaGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetStudentByRaApiStudentsStudentRaGetQueryOptions(studentRa,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Update Student By Ra
 */
export const updateStudentByRaApiStudentsStudentRaPatch = (
    studentRa: number,
    bodyUpdateStudentByRaApiStudentsStudentRaPatch: BodyType<BodyUpdateStudentByRaApiStudentsStudentRaPatch>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      const formUrlEncoded = new URLSearchParams();
if(bodyUpdateStudentByRaApiStudentsStudentRaPatch.name !== undefined && bodyUpdateStudentByRaApiStudentsStudentRaPatch.name !== null) {
 formUrlEncoded.append('name', bodyUpdateStudentByRaApiStudentsStudentRaPatch.name)
 }
if(bodyUpdateStudentByRaApiStudentsStudentRaPatch.ra !== undefined && bodyUpdateStudentByRaApiStudentsStudentRaPatch.ra !== null) {
 formUrlEncoded.append('ra', bodyUpdateStudentByRaApiStudentsStudentRaPatch.ra.toString())
 }
if(bodyUpdateStudentByRaApiStudentsStudentRaPatch.image_base64 !== undefined && bodyUpdateStudentByRaApiStudentsStudentRaPatch.image_base64 !== null) {
 formUrlEncoded.append('image_base64', bodyUpdateStudentByRaApiStudentsStudentRaPatch.image_base64)
 }
if(bodyUpdateStudentByRaApiStudentsStudentRaPatch.active !== undefined && bodyUpdateStudentByRaApiStudentsStudentRaPatch.active !== null) {
 formUrlEncoded.append('active', bodyUpdateStudentByRaApiStudentsStudentRaPatch.active.toString())
 }

      return customInstance<unknown>(
      {url: `/api/students/${studentRa}`, method: 'PATCH',
      headers: {'Content-Type': 'application/x-www-form-urlencoded', },
       data: formUrlEncoded
    },
      options);
    }
  


export const getUpdateStudentByRaApiStudentsStudentRaPatchMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateStudentByRaApiStudentsStudentRaPatch>>, TError,{studentRa: number;data: BodyType<BodyUpdateStudentByRaApiStudentsStudentRaPatch>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateStudentByRaApiStudentsStudentRaPatch>>, TError,{studentRa: number;data: BodyType<BodyUpdateStudentByRaApiStudentsStudentRaPatch>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateStudentByRaApiStudentsStudentRaPatch>>, {studentRa: number;data: BodyType<BodyUpdateStudentByRaApiStudentsStudentRaPatch>}> = (props) => {
          const {studentRa,data} = props ?? {};

          return  updateStudentByRaApiStudentsStudentRaPatch(studentRa,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateStudentByRaApiStudentsStudentRaPatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateStudentByRaApiStudentsStudentRaPatch>>>
    export type UpdateStudentByRaApiStudentsStudentRaPatchMutationBody = BodyType<BodyUpdateStudentByRaApiStudentsStudentRaPatch>
    export type UpdateStudentByRaApiStudentsStudentRaPatchMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Update Student By Ra
 */
export const useUpdateStudentByRaApiStudentsStudentRaPatch = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateStudentByRaApiStudentsStudentRaPatch>>, TError,{studentRa: number;data: BodyType<BodyUpdateStudentByRaApiStudentsStudentRaPatch>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateStudentByRaApiStudentsStudentRaPatch>>,
        TError,
        {studentRa: number;data: BodyType<BodyUpdateStudentByRaApiStudentsStudentRaPatch>},
        TContext
      > => {

      const mutationOptions = getUpdateStudentByRaApiStudentsStudentRaPatchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Create Students By Csv
 */
export const createStudentsByCsvApiStudentsCsvPost = (
    bodyCreateStudentsByCsvApiStudentsCsvPost: BodyType<BodyCreateStudentsByCsvApiStudentsCsvPost>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append('csv_file', bodyCreateStudentsByCsvApiStudentsCsvPost.csv_file)

      return customInstance<unknown>(
      {url: `/api/students/csv`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      options);
    }
  


export const getCreateStudentsByCsvApiStudentsCsvPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createStudentsByCsvApiStudentsCsvPost>>, TError,{data: BodyType<BodyCreateStudentsByCsvApiStudentsCsvPost>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createStudentsByCsvApiStudentsCsvPost>>, TError,{data: BodyType<BodyCreateStudentsByCsvApiStudentsCsvPost>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createStudentsByCsvApiStudentsCsvPost>>, {data: BodyType<BodyCreateStudentsByCsvApiStudentsCsvPost>}> = (props) => {
          const {data} = props ?? {};

          return  createStudentsByCsvApiStudentsCsvPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateStudentsByCsvApiStudentsCsvPostMutationResult = NonNullable<Awaited<ReturnType<typeof createStudentsByCsvApiStudentsCsvPost>>>
    export type CreateStudentsByCsvApiStudentsCsvPostMutationBody = BodyType<BodyCreateStudentsByCsvApiStudentsCsvPost>
    export type CreateStudentsByCsvApiStudentsCsvPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Create Students By Csv
 */
export const useCreateStudentsByCsvApiStudentsCsvPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createStudentsByCsvApiStudentsCsvPost>>, TError,{data: BodyType<BodyCreateStudentsByCsvApiStudentsCsvPost>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createStudentsByCsvApiStudentsCsvPost>>,
        TError,
        {data: BodyType<BodyCreateStudentsByCsvApiStudentsCsvPost>},
        TContext
      > => {

      const mutationOptions = getCreateStudentsByCsvApiStudentsCsvPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Recognize
 */
export const recognizeApiFacialRecognitionRecognizePost = (
    bodyRecognizeApiFacialRecognitionRecognizePost: BodyType<BodyRecognizeApiFacialRecognitionRecognizePost>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append('image', bodyRecognizeApiFacialRecognitionRecognizePost.image)

      return customInstance<unknown>(
      {url: `/api/facial_recognition/recognize`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      options);
    }
  


export const getRecognizeApiFacialRecognitionRecognizePostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recognizeApiFacialRecognitionRecognizePost>>, TError,{data: BodyType<BodyRecognizeApiFacialRecognitionRecognizePost>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof recognizeApiFacialRecognitionRecognizePost>>, TError,{data: BodyType<BodyRecognizeApiFacialRecognitionRecognizePost>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof recognizeApiFacialRecognitionRecognizePost>>, {data: BodyType<BodyRecognizeApiFacialRecognitionRecognizePost>}> = (props) => {
          const {data} = props ?? {};

          return  recognizeApiFacialRecognitionRecognizePost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RecognizeApiFacialRecognitionRecognizePostMutationResult = NonNullable<Awaited<ReturnType<typeof recognizeApiFacialRecognitionRecognizePost>>>
    export type RecognizeApiFacialRecognitionRecognizePostMutationBody = BodyType<BodyRecognizeApiFacialRecognitionRecognizePost>
    export type RecognizeApiFacialRecognitionRecognizePostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Recognize
 */
export const useRecognizeApiFacialRecognitionRecognizePost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof recognizeApiFacialRecognitionRecognizePost>>, TError,{data: BodyType<BodyRecognizeApiFacialRecognitionRecognizePost>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof recognizeApiFacialRecognitionRecognizePost>>,
        TError,
        {data: BodyType<BodyRecognizeApiFacialRecognitionRecognizePost>},
        TContext
      > => {

      const mutationOptions = getRecognizeApiFacialRecognitionRecognizePostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Represent Face
 */
export const representFaceApiFacialRecognitionRepresentPost = (
    deepFaceRepresentRequest: BodyType<DeepFaceRepresentRequest>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/facial_recognition/represent`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: deepFaceRepresentRequest, signal
    },
      options);
    }
  


export const getRepresentFaceApiFacialRecognitionRepresentPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof representFaceApiFacialRecognitionRepresentPost>>, TError,{data: BodyType<DeepFaceRepresentRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof representFaceApiFacialRecognitionRepresentPost>>, TError,{data: BodyType<DeepFaceRepresentRequest>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof representFaceApiFacialRecognitionRepresentPost>>, {data: BodyType<DeepFaceRepresentRequest>}> = (props) => {
          const {data} = props ?? {};

          return  representFaceApiFacialRecognitionRepresentPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RepresentFaceApiFacialRecognitionRepresentPostMutationResult = NonNullable<Awaited<ReturnType<typeof representFaceApiFacialRecognitionRepresentPost>>>
    export type RepresentFaceApiFacialRecognitionRepresentPostMutationBody = BodyType<DeepFaceRepresentRequest>
    export type RepresentFaceApiFacialRecognitionRepresentPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Represent Face
 */
export const useRepresentFaceApiFacialRecognitionRepresentPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof representFaceApiFacialRecognitionRepresentPost>>, TError,{data: BodyType<DeepFaceRepresentRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof representFaceApiFacialRecognitionRepresentPost>>,
        TError,
        {data: BodyType<DeepFaceRepresentRequest>},
        TContext
      > => {

      const mutationOptions = getRepresentFaceApiFacialRecognitionRepresentPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Verify Face
 */
export const verifyFaceApiFacialRecognitionVerifyPost = (
    deepFaceVerifyRequest: BodyType<DeepFaceVerifyRequest>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/facial_recognition/verify`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: deepFaceVerifyRequest, signal
    },
      options);
    }
  


export const getVerifyFaceApiFacialRecognitionVerifyPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyFaceApiFacialRecognitionVerifyPost>>, TError,{data: BodyType<DeepFaceVerifyRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof verifyFaceApiFacialRecognitionVerifyPost>>, TError,{data: BodyType<DeepFaceVerifyRequest>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyFaceApiFacialRecognitionVerifyPost>>, {data: BodyType<DeepFaceVerifyRequest>}> = (props) => {
          const {data} = props ?? {};

          return  verifyFaceApiFacialRecognitionVerifyPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyFaceApiFacialRecognitionVerifyPostMutationResult = NonNullable<Awaited<ReturnType<typeof verifyFaceApiFacialRecognitionVerifyPost>>>
    export type VerifyFaceApiFacialRecognitionVerifyPostMutationBody = BodyType<DeepFaceVerifyRequest>
    export type VerifyFaceApiFacialRecognitionVerifyPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Verify Face
 */
export const useVerifyFaceApiFacialRecognitionVerifyPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyFaceApiFacialRecognitionVerifyPost>>, TError,{data: BodyType<DeepFaceVerifyRequest>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof verifyFaceApiFacialRecognitionVerifyPost>>,
        TError,
        {data: BodyType<DeepFaceVerifyRequest>},
        TContext
      > => {

      const mutationOptions = getVerifyFaceApiFacialRecognitionVerifyPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
